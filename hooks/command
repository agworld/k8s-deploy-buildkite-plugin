#!/bin/bash

function updateImage () {
    # Start deploys in parallel
    local i=0
    local deployment_name_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DEPLOYMENTS_${i}_NAME"
    local deploy_pids=()
    local exit_codes=()
    local should_rollback=0

    while [[ -n "${!deployment_name_envvar:-}" ]] ; do
        updateDeployment "$i" &
        deploy_pids+=($!)

        i=$((i+1))
        deployment_name_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DEPLOYMENTS_${i}_NAME"
    done

    for i in ${!deploy_pids[@]}; do
        wait ${deploy_pids[$i]}

        exit_codes+=($?)

        if [ $? -ne 0 ]; then
            should_rollback=1
        fi
    done

    # Rollback and exit

    if [ $should_rollback -ne 0 ]; then
        # Rollback any successful deployments, ignore unsuccesful ones since they should have never deployed

        for i in ${!exit_codes[@]}; do
            if [ ${exit_codes[$i]} -eq "0" ]; then
                rollbackDeployment "${i}" &
            fi
        done

        wait
        exit 1
    fi

    # Wait for deployments to finish

    local rollout_pids=()

    for i in ${!deploy_pids[@]}; do
        waitForDeploymentRollout "${i}" &
        rollout_pids+=($!)
    done

    for i in ${!rollout_pids[@]}; do
        wait ${rollout_pids[$i]}

        if [ $? -ne 0 ]; then
            should_rollback=1
        fi
    done

    # Rollback and exit

    if [ $should_rollback -ne 0 ]; then
        # Rollback any successful deployments, ignore unsuccesful ones since they should have never deployed
        echo "--- :bk-status-failed: Rolling back deployment"

        for i in ${!exit_codes[@]}; do
            rollbackDeployment "${i}" &
        done

        wait
        exit 1
    fi

    exit 0
}

function waitForDeploymentRollout () {
    local deployment_index=$1
    local namespace_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DEPLOYMENTS_${deployment_index}_NAMESPACE"
    local deployment_name_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DEPLOYMENTS_${deployment_index}_NAME"

    local namespace="${!namespace_envvar:-default}"
    local deployment_name="${!deployment_name_envvar}"
    local timeout="${BUILDKITE_PLUGIN_K8S_DEPLOY_TIMEOUT:-30}s"

    if ! kubectl rollout status deployment/$deployment_name -n $namespace --timeout=$timeout ; then
        echo "--- :bk-status-failed: Deploy failed for '${deployment_name}'"
        exit 1
    fi

    echo "--- :bk-status-passed: Deploy success for '${deployment_name}'"
    exit 0
}

function rollbackDeployment () {
    local deployment_index=$1
    local namespace_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DEPLOYMENTS_${deployment_index}_NAMESPACE"
    local deployment_name_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DEPLOYMENTS_${deployment_index}_NAME"

    local namespace="${!namespace_envvar:-default}"
    local deployment_name="${!deployment_name_envvar}"

    kubectl rollout undo deployment/$deployment_name -n $namespace
    if [ $? -ne 0 ]; then
        echo "--- :bk-status-failed: Failed to rollback '${deployment_name}'"
        exit 1
    else
        echo "--- ↩️  Rollback success for '${deployment_name}'"
    fi

    exit 0
}

function updateDeployment () {
    local deployment_index=$1

    local i=0
    local image_name_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DEPLOYMENTS_${deployment_index}_CONTAINERS_${i}_IMAGE"
    local container_string=""

    # Extract each container to be updated
    while [[ -n "${!image_name_envvar:-}" ]] ; do
        local container_name_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DEPLOYMENTS_${deployment_index}_CONTAINERS_${i}_CONTAINERNAME"

        container_string=("${container_string} ${!container_name_envvar}=${!image_name_envvar}")

        i=$((i+1))
        image_name_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DEPLOYMENTS_${deployment_index}_CONTAINERS_${i}_IMAGE"
    done

    local namespace_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DEPLOYMENTS_${deployment_index}_NAMESPACE"
    local deployment_name_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DEPLOYMENTS_${deployment_index}_NAME"

    local namespace="${!namespace_envvar:-default}"
    local deployment_name="${!deployment_name_envvar}"
    local timeout="${BUILDKITE_PLUGIN_K8S_DEPLOY_TIMEOUT:-300}s"
    local annotation="Buildkite deploy $(date +'%d-%m-%Y %H:%M')."

    if [[ ! -z "${BUILDKITE_UNBLOCKER}" ]]; then
        annotation="${annotation} unblocker='${BUILDKITE_UNBLOCKER}'"
    fi

    local git_commit_string=$(git log --oneline -n 1) || "$BUILDKITE_COMMIT $BUILDKITE_MESSAGE"
    if [[ ! -z "${BUILDKITE_MESSAGE}" ]]; then
        annotation="${annotation} commit='${git_commit_string}'"
    fi

    echo "--- :kubernetes: Deploying new image to ${deployment_name}"

    local patch_json_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DEPLOYMENTS_${deployment_index}_PATCHJSON"
    if [[ ! -z "${!patch_json_envvar:-}" ]]; then
        local temp_filename="/tmp/${deployment_index}_${BUILDKITE_COMMIT}.json"
        echo "${!patch_json_envvar}" > $temp_filename

        kubectl patch deployment/${deployment_name} --namespace="${namespace}" --type="json" -p="$(cat ${temp_filename})"
        if [ $? -ne 0 ]; then
            echo "--- :bk-status-failed: Deployment patch failed for '${deployment_name}'"
            rm $temp_filename
            exit 1
        fi

        rm $temp_filename
    fi

    kubectl set image deployment/$deployment_name $container_string --record -n $namespace
    if [ $? -ne 0 ]; then
        echo "--- :bk-status-failed: Failed to set image for '${deployment_name}'"
        exit 1
    fi

    kubectl annotate deployment/$deployment_name kubernetes.io/change-cause="${annotation}" -n $namespace
    if [ $? -ne 0 ]; then
        echo "--- :bk-status-failed: Failed to annotate deployment for '${deployment_name}'"
        exit 1
    fi

    exit 0
}

function promoteImage () {
    # Login to source repository

    aws ecr get-login-password --region $BUILDKITE_PLUGIN_K8S_DEPLOY_SOURCEIMAGE_REGION | docker login --username AWS --password-stdin $BUILDKITE_PLUGIN_K8S_DEPLOY_SOURCEIMAGE_REPOSITORYURL
    if [ $? -ne 0 ]; then
        echo "--- :bk-status-failed: Promotion failed. Authentication failed with source repository"
        exit 1
    fi

    # Test if the image already exists on the kubernetes host

    local should_cleanup_source_image=1

    if docker inspect --type=image $BUILDKITE_PLUGIN_K8S_DEPLOY_SOURCEIMAGE_REPOSITORYURL/$BUILDKITE_PLUGIN_K8S_DEPLOY_SOURCEIMAGE_IMAGE ; then
        echo "Image tag already exists on host"
        should_cleanup_source_image=0
    fi

    # Pull the source image

    docker pull $BUILDKITE_PLUGIN_K8S_DEPLOY_SOURCEIMAGE_REPOSITORYURL/$BUILDKITE_PLUGIN_K8S_DEPLOY_SOURCEIMAGE_IMAGE
    if [ $? -ne 0 ]; then
        echo "--- :bk-status-failed: Promotion failed. Failed to pull source image"
        exit 1
    fi

    # Loop over destinations and push in parallel

    local i=0
    local destination_image_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DESTINATIONIMAGES_${i}_IMAGE"
    local destination_repository_url_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DESTINATIONIMAGES_${i}_REPOSITORYURL"
    local destination_region_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DESTINATIONIMAGES_${i}_REGION"

    local push_pids=()

    while [[ -n "${!destination_image_envvar:-}" ]] ; do
        # Authenticate with the destination region
        aws ecr get-login-password --region ${!destination_region_envvar} | docker login --username AWS --password-stdin ${!destination_repository_url_envvar}
        if [ $? -ne 0 ]; then
            echo "--- :bk-status-failed: Promotion failed. Authentication failed with destination repository ${!destination_repository_url_envvar}"
            exit 1
        fi
        
        # Tag and push the image
        docker tag $BUILDKITE_PLUGIN_K8S_DEPLOY_SOURCEIMAGE_REPOSITORYURL/$BUILDKITE_PLUGIN_K8S_DEPLOY_SOURCEIMAGE_IMAGE ${!destination_repository_url_envvar}/${!destination_image_envvar}

        # Start push in parallel
        docker push ${!destination_repository_url_envvar}/${!destination_image_envvar} &
        push_pids+=($!)

        i=$((i+1))
        destination_image_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DESTINATIONIMAGES_${i}_IMAGE"
        destination_repository_url_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DESTINATIONIMAGES_${i}_REPOSITORYURL"
        destination_region_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DESTINATIONIMAGES_${i}_REGION"
    done

    # Wait for each image push to complete

    local failure_count=0

    for i in ${!push_pids[@]}; do
        wait ${push_pids[$i]}

        local push_exit_code=$?

        # Cleanup the tag locally

        destination_image_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DESTINATIONIMAGES_${i}_IMAGE"
        destination_repository_url_envvar="BUILDKITE_PLUGIN_K8S_DEPLOY_DESTINATIONIMAGES_${i}_REPOSITORYURL"

        docker rmi ${!destination_repository_url_envvar}/${!destination_image_envvar}

        if [ push_exit_code -ne 0 ]; then
            echo "--- :bk-status-failed: Promotion failed. Push failed to destination repository ${!destination_repository_url_envvar}"
            failure_count=$((failure_count+1))
        else
            echo "--- :bk-status-passed: Image promotion success - ${!destination_repository_url_envvar}/${!destination_image_envvar}"
        fi
    done

    # Clean up the source image if it didn't exist when we started

    if [ "$should_cleanup_source_image" -eq "1" ]; then
        docker image rm $BUILDKITE_PLUGIN_K8S_DEPLOY_SOURCEIMAGE_REPOSITORYURL/$BUILDKITE_PLUGIN_K8S_DEPLOY_SOURCEIMAGE_IMAGE
    fi

    # Fail this build step if there was any failures pushing an image

    if [ "$failure_count" -eq "0" ]; then
        exit 0
    else
        exit 1
    fi
}

case "$BUILDKITE_PLUGIN_K8S_DEPLOY_ACTION" in
    'updateImage')
        updateImage
        ;;
    'promoteImage')
        promoteImage
        ;;
    *)
        echo "Invalid action: $BUILDKITE_PLUGIN_K8S_DEPLOY_ACTION"
        ;;
esac
